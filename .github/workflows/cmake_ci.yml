name: cmake ci linux macos windows

on: [push, pull_request]

jobs:
  pip-requirements:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          cache: 'pip'
          python-version: '3.10'
      - name: Generate requirements.txt
        run: |
          pip install pip-tools
          pip-compile --all-build-deps python/finufft/pyproject.toml -o requirements.txt
          echo pytest >> requirements.txt
          sed -i -E 's/(==|>=|<=|>|<|~=|!=).*//' requirements.txt
          cat requirements.txt
      - name: Upload requirements.txt
        uses: actions/upload-artifact@v4
        with:
          name: requirements
          path: requirements.txt

  cache:
    strategy:
      matrix:
        os: [ubuntu-22.04]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: create cache directory
        shell: bash
        run: mkdir -p "cpm"
      - name: Check if cache exists
        id: cache
        uses: actions/cache@v4
        with:
          key: cpm-cache-00-${{ runner.os == 'windows' && 'windows-' || '' }}${{ hashFiles('**/CMakeLists.txt', 'cmake/**') }}
          enableCrossOsArchive: true
          path: cpm
      - name: Setup Cpp (on cache miss)
        if: steps.cache.outputs.cache-hit != 'true'
        uses: aminya/setup-cpp@v1
        with:
          cmake: true
      - name: Download dependencies in cache (Linux)
        if: steps.cache.outputs.cache-hit != 'true' && runner.os == 'Linux'
        run: |
          cmake -S . -B ./build -DCPM_SOURCE_CACHE="cpm"
          rm -rf build
          cmake -S . -B ./build -DFINUFFT_USE_DUCC0=ON -DCPM_SOURCE_CACHE="cpm"
      - name: Download dependencies in cache (Windows)
        if: steps.cache.outputs.cache-hit != 'true' && runner.os != 'Linux'
        run: |
          cmake -S . -B build -DCPM_SOURCE_CACHE="cpm"
          rm build -r -force
          cmake -S . -B build -DFINUFFT_USE_DUCC0=ON -DCPM_SOURCE_CACHE="cpm"
      - name: Cache dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          key: cpm-cache-00-${{ runner.os == 'windows' && 'windows-' || '' }}${{ hashFiles('**/CMakeLists.txt', 'cmake/**') }}
          enableCrossOsArchive: true
          path: cpm

  cmake-ci:
    runs-on: ${{ matrix.os }}
    needs: [cache, pip-requirements]
    env:
      CMAKE_GENERATOR: Ninja
      CPM_SOURCE_CACHE: cpm
      CTEST_OUTPUT_ON_FAILURE: "1"
      SCCACHE_GHA_ENABLED: "true"
      SCCACHE_GHA_VERSION: "0"
      CMAKE_C_COMPILER_LAUNCHER: sccache
      CMAKE_CXX_COMPILER_LAUNCHER: sccache
      CMAKE_CUDA_COMPILER_LAUNCHER: sccache
      CMAKE_EXPORT_COMPILE_COMMANDS: "OFF"
      SCCACHE_CACHE_SIZE: "5G"
    strategy:
      fail-fast: false
      matrix:
        include:
          - { os: ubuntu-22.04, toolchain: gcc-10 }

    steps:
      - name: Free Disk Space (Ubuntu)
        if: runner.os == 'Linux'
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: false
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Restore Cache
        uses: actions/cache/restore@v4
        with:
          key: cpm-cache-00-${{ runner.os == 'windows' && 'windows-' || '' }}${{ hashFiles('**/CMakeLists.txt', 'cmake/**') }}
          enableCrossOsArchive: true
          path: cpm

      - name: Download requirements.txt
        uses: actions/download-artifact@v4
        with:
          name: requirements

      - name: Run sccache-cache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Setup Cpp
        uses: aminya/setup-cpp@v1
        with:
          compiler: ${{ matrix.toolchain }}
          vcvarsall: true
          cmake: true
          ninja: true

      - name: Install toolchain + FFTW (macOS)
        if: startsWith(matrix.os, 'macos-')
        run: |
          export HOMEBREW_NO_ANALYTICS=1 HOMEBREW_NO_INSTALL_CLEANUP=1
          brew install libomp fftw
          {
            echo "LDFLAGS=-L$(brew --prefix libomp)/lib"
            echo "CPPFLAGS=-I$(brew --prefix libomp)/include"
            echo "LIBRARY_PATH=$(brew --prefix libomp)/lib"
            echo "DYLD_LIBRARY_PATH=$(brew --prefix libomp)/lib"
            echo "CMAKE_PREFIX_PATH=$(brew --prefix libomp)"
            ver="${{ matrix.os }}"; ver="${ver#macos-}"
            echo "MACOSX_DEPLOYMENT_TARGET=${ver}.0"
          } >> "$GITHUB_ENV"

      - name: Install fftw (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt update
          sudo apt install -y libfftw3-dev

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
          cache-dependency-path: requirements.txt

      - name: Install Python requirements
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install -r requirements.txt

      - name: Build and test configurations
        shell: bash
        run: |
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            configs=("build_type=Release ducc_fft=On" "build_type=Debug ducc_fft=On")
          else
            configs=("build_type=Release ducc_fft=On")
          fi

          if [[ "${{ matrix.toolchain }}" == "msvc" ]]; then
            arch_flags=("/arch:AVX2" "/arch:SSE2" "native")
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            arch_flags=("")
            lscpu
            flags=$(lscpu | awk -F: 'BEGIN{IGNORECASE=1} $1 ~ /flags/ {print tolower($2)}')
            if [[ $flags == *avx512f* && $flags == *avx512dq* && $flags == *avx512cd* && $flags == *avx512bw* && $flags == *avx512vl* ]]; then
              arch_flags+=("-march=x86-64-v4")
            fi
          else
           arch_flags=("native")
          fi

          build_dir="build"

          for arch in "${arch_flags[@]}"; do
            arch_dir=$(echo "$arch" | tr -c 'A-Za-z0-9' '_')
            for cfg in "${configs[@]}"; do
              eval "$cfg"

              # delete the build directory every time

              rm -rf $build_dir

              sanitizers="OFF"
              if [[ "$build_type" == "Debug" && "$RUNNER_OS" != "Windows" ]]; then
                sanitizers="ON"
              fi

              cmake -E make_directory "$build_dir"
              cmake -S . -B "$build_dir" \
                -DCMAKE_BUILD_TYPE=$build_type \
                -DFINUFFT_ARCH_FLAGS="$arch" \
                -DFINUFFT_BUILD_EXAMPLES=ON \
                -DFINUFFT_BUILD_TESTS=ON \
                -DFINUFFT_USE_DUCC0=$ducc_fft \
                -DFINUFFT_USE_SANITIZERS=$sanitizers \
                -DCMAKE_MSVC_DEBUG_INFORMATION_FORMAT=Embedded \
                -DCMAKE_POLICY_DEFAULT_CMP0141=NEW
                # CMake will pick the toolchain set by setup-cpp (and macOS brew block for gcc-14).

              cmake --build "$build_dir" --config "$build_type"
              ctest --test-dir "$build_dir" --output-on-failure

              python3 -m pip install \
                --verbose \
                -C cmake.define.CMAKE_BUILD_TYPE=$build_type \
                -C cmake.define.FINUFFT_ARCH_FLAGS="$arch" \
                -C cmake.define.FINUFFT_USE_DUCC0=$ducc_fft \
                -C cmake.define.CMAKE_MSVC_DEBUG_INFORMATION_FORMAT=Embedded \
                -C cmake.define.CMAKE_POLICY_DEFAULT_CMP0141=NEW \
                python/finufft

              python3 -m pytest python/finufft/test
            done
          done

      - name: Setup tmate session
        if: ${{ failure() }}
        uses: mxschmitt/action-tmate@v3

  cleanup:
    runs-on: ubuntu-22.04
    needs: cmake-ci
    steps:
      - name: Artifact cleanup
        uses: geekyeggo/delete-artifact@v5
        with:
          name: requirements
